#!/usr/bin/env python3

import io
import os
import sys
import copy
import numpy
import argparse
from load import parse_map_file_signature
from level import Level
from debug import debug
from common import die, warn, load_file
from records import CollectionRecords
from colorize import *
from sizetools import set_fitting_map_size
from progressline import ProgressLine
from sokobansolver import *
from sokobanparser import create_sok_map, find_map_file
from processcmdargs import process_cmdargs

sys.argv[0] = 'sokodun'

parser = argparse.ArgumentParser()
parser.add_argument('-d', '--debug', metavar='SELECTOR', action='append', default=[], help='debug level or feature (repeatable)')
parser.add_argument('-C', '--list-collections', help="list all collections", action='store_true')
parser.add_argument('-L', '--list-ll-collections', help="list all letslogic collections", action='store_true')
parser.add_argument('-n', '--use-numeric', help="use numeric ids to list collections", action='store_true')
parser.add_argument('-r', '--reverse-barrel-mode', '--reverse', help="apply reverse barrel mode to custom levels", action='store_true', default=None)
parser.add_argument('-p', '--run-profiler', help="run code with profiler", action='store_true')
parser.add_argument('-s', '--show-sok', help="show map in sok format rather than internal", action='store_true')
parser.add_argument('-m', '--by-moves', help="find move optimal solution, not push/pull optimal", action='store_true')
parser.add_argument('-A', '--astar', help="use A* algorithm to find solution", action='store_true')
parser.add_argument('-B', '--bfs', help="use BFS algorithm to find solution", action='store_true')
parser.add_argument('-D', '--dfs', help="use DFS algorithm to find solution", action='store_true')
parser.add_argument('-G', '--greed', help="use Greedy algorithm to find solution", action='store_true')
parser.add_argument('-U', '--ucs', help="use Uniform Cost algorithm to find solution", action='store_true')
parser.add_argument('-_', '--disable-prepare', help="do not prepare costs for lower-bound", action='store_true')
parser.add_argument('-0', '--disable-budget', help="do not report progress every second", action='store_true')
parser.add_argument('-1', '--return-first', help="return first found solution (not optimal)", action='store_true')
parser.add_argument('-x', '--show-dead', help="show dead-barrel cells on map", action='store_true')
parser.add_argument('-t', '--show-time', help="show solution time in seconds", action='store_true')
parser.add_argument('-T', '--limit-time', help="limit solution time to given seconds", metavar='SEC', action='store')
parser.add_argument('-R', '--record-file', help='compare with records; "." (in-level), "" (disable)', metavar='FILE', action='store')
parser.add_argument('-q', '--quiet', help="do not show map (+ progress on second -q)", action='count')
parser.add_argument("args", nargs='*', help="level-id, collection-id, map-file or url")

cmdargs = parser.parse_args()

reverse_barrel_mode = cmdargs.reverse_barrel_mode
record_filename = cmdargs.record_file
disable_prepare = cmdargs.disable_prepare
disable_budget = cmdargs.disable_budget
solution_type = SOLUTION_TYPE_BY_MOVES if cmdargs.by_moves else SOLUTION_TYPE_BY_SHIFTS
solution_alg = SOLUTION_ALG_ASTAR if cmdargs.astar else SOLUTION_ALG_BFS if cmdargs.bfs else SOLUTION_ALG_DFS if cmdargs.dfs else SOLUTION_ALG_GREED if cmdargs.greed else SOLUTION_ALG_UCS if cmdargs.ucs else None
return_first = cmdargs.return_first
limit_time = int(cmdargs.limit_time) if cmdargs.limit_time and cmdargs.limit_time.isdigit() else None
show_time = cmdargs.show_time
show_dead = cmdargs.show_dead and 'auto'
show_sok = cmdargs.show_sok
quiet = cmdargs.quiet or 0

set_fitting_map_size((5, 5))

level_configs, custom_collection = process_cmdargs(cmdargs)

if not level_configs:
	die("No valid levels given, try --help")

level = Level()

def create_sokoban_map(map_string):
	file = io.StringIO(map_string)
	error, puzzle_type, size = parse_map_file_signature(file)
	assert not error, error
	assert puzzle_type == 'BarrelPuzzle', "Unsupported puzzle-type %s" % puzzle_type
	lines = [line.rstrip('\n') for line in file.readlines()[0:size[1]]]
	return numpy.array([list(line) for line in lines], dtype='<U1').T

def create_solver(map_string, reverse_barrel_mode=False):
	map = create_sokoban_map(map_string)
	if not quiet and show_sok:
		print(create_sok_map(map), end='')
	return create_sokoban_solver(map, reverse_barrel_mode, solution_alg, return_first, not quiet and not show_sok, show_dead, limit_time)

show_progress = quiet <= 1 and not debug.has('solv')
progress_line = ProgressLine(show_progress)

record_key = "move-record" if cmdargs.by_moves else "push-record"
records_in_level_configs = lambda: (level_config.get("puzzle-config", {}).get(record_key) for level_config in level_configs)
if record_filename == '.' or record_filename is None and any(records_in_level_configs()):
	record_filename = [*records_in_level_configs()]

coll_records = CollectionRecords(record_filename, cmdargs.by_moves) if record_filename else None
is_optimal = not return_first and not reverse_barrel_mode and solution_alg in (None, SOLUTION_ALG_ASTAR, SOLUTION_ALG_BFS, SOLUTION_ALG_UCS)

for level_index, level_config in enumerate(level_configs):
	level_index += 1
	level.set_from_config(custom_collection, level_index, level_config)
	if level.puzzle_type != 'BarrelPuzzle':
		warn("Ignoring level %d of non BarrelPuzzle type (%s)" % (level_index, level.puzzle_type))
		if coll_records: coll_records.cmp_level_result(None)
		continue
	if level.map_file is not None:
		level.map_string = load_file(find_map_file(level.map_file))
	if level.map_string is None:
		warn("Ignoring level %d of auto-generated BarrelPuzzle, try the same in dungeon" % level_index)
		if coll_records: coll_records.cmp_level_result(None)
		continue
	if quiet <= 3:
		print("Solving level %s of %d: %s" % (colorize(level_index, COLOR_BOLD), len(level_configs), colorize(level.name, COLOR_ITALIC)))
	solver = create_solver(level.map_string, reverse_barrel_mode)
	solver.solution_type = solution_type
	solver.disable_budget = disable_budget
	solver.disable_prepare = disable_prepare

	def show_solution(solution_items):
		if coll_records:
			record_str = colorize_auto(coll_records.record_str_at_result)
			c = coll_records.cmp_level_result(solver.last_solution_nums_str)
			record_status_str = colorize_auto('N/A' if c is None else 'OK' if c == 0 else 'WORSE' if c == 1 else 'NEW RECORD')
		if show_time:
			print("Time: %s" % colorize_auto(solver.last_solution_time_str))
		if quiet >= 3 and is_optimal and solution_items and coll_records:
			print("Solution: %s" % record_status_str)
		elif not solution_items:
			print("Solution %s" % colorize_auto("not found"))
		elif quiet >= 3:
			print("Solution %s" % colorize_auto("found"))
		else:
			print("Solution %s: %s" % (colorize_auto(solver.last_solution_nums_str), solver.last_solution_str))
		if quiet <= 2 and coll_records:
			print("Record %s: %s" % (record_str, record_status_str))

	try:
		while True:
			solution_items, msg = solver.find_solution_func()
			if not msg:
				break
			progress_line.put(msg)
		progress_line.put()

		show_solution(solution_items)
		if quiet <= 3: print()
	except KeyboardInterrupt:
		print()
		solution_items = solver.get_found_solution_items("terminated")
		show_solution(solution_items)
		print("Terminated by user. Press Enter to continue, or Ctrl-C to stop")
		try:
			sys.stdin.readline()
		except KeyboardInterrupt:
			print()
			exit(1)

if coll_records and os.environ.get("UPDATE_RECORDS", False):
	updated = coll_records.update_file()
	print(f"Records file {coll_records.filename} is {'' if updated else 'not '}updated")
