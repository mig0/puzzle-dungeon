#!/usr/bin/env python3

import io
import sys
import copy
import numpy
import argparse
from load import parse_map_file_signature
from level import Level
from debug import debug
from common import die, warn
from sizetools import set_fitting_map_size
from progressline import ProgressLine
from sokobansolver import *
from sokobanparser import create_sok_map
from processcmdargs import process_cmdargs

sys.argv[0] = 'sokodun'

parser = argparse.ArgumentParser()
parser.add_argument('-d', '--debug', metavar='SELECTOR', action='append', default=[], help='debug level or feature (repeatable)')
parser.add_argument('-C', '--list-collections', help="list all collections", action='store_true')
parser.add_argument('-L', '--list-ll-collections', help="list all letslogic collections", action='store_true')
parser.add_argument('-n', '--use-numeric', help="use numeric ids to list collections", action='store_true')
parser.add_argument('-r', '--reverse-barrel-mode', '--reverse', help="apply reverse barrel mode to custom levels", action='store_true')
parser.add_argument('-p', '--run-profiler', help="run code with profiler", action='store_true')
parser.add_argument('-s', '--show-sok', help="show map in sok format rather than internal", action='store_true')
parser.add_argument('-m', '--by-moves', help="find move optimal solution, not push/pull optimal", action='store_true')
parser.add_argument('-A', '--astar', help="use A* algorithm to find solution", action='store_true')
parser.add_argument('-B', '--bfs', help="use BFS algorithm to find solution", action='store_true')
parser.add_argument('-D', '--dfs', help="use DFS algorithm to find solution", action='store_true')
parser.add_argument('-G', '--greed', help="use Greedy algorithm to find solution", action='store_true')
parser.add_argument('-U', '--ucs', help="use Uniform Cost algorithm to find solution", action='store_true')
parser.add_argument('-0', '--disable-budget', help="do not report progress every second", action='store_true')
parser.add_argument('-1', '--return-first', help="return first found solution (not optimal)", action='store_true')
parser.add_argument('-x', '--show-dead', help="show dead-barrel cells on map", action='store_true')
parser.add_argument('-t', '--show-time', help="show solution time in seconds", action='store_true')
parser.add_argument('-T', '--limit-time', help="limit solution time to given seconds", metavar='SEC', action='store')
parser.add_argument('-q', '--quiet', help="do not show map (+ progress on second -q)", action='count')
parser.add_argument("args", nargs='*', help="level-id, collection-id or map-file")

cmdargs = parser.parse_args()

reverse_barrel_mode = cmdargs.reverse_barrel_mode
disable_budget = cmdargs.disable_budget
solution_type = SOLUTION_TYPE_BY_MOVES if cmdargs.by_moves else SOLUTION_TYPE_BY_SHIFTS
solution_alg = SOLUTION_ALG_ASTAR if cmdargs.astar else SOLUTION_ALG_BFS if cmdargs.bfs else SOLUTION_ALG_DFS if cmdargs.dfs else SOLUTION_ALG_GREED if cmdargs.greed else SOLUTION_ALG_UCS if cmdargs.ucs else None
return_first = cmdargs.return_first
limit_time = int(cmdargs.limit_time) if cmdargs.limit_time and cmdargs.limit_time.isdigit() else None
show_time = cmdargs.show_time
show_dead = cmdargs.show_dead
show_sok = cmdargs.show_sok
quiet = cmdargs.quiet or 0

set_fitting_map_size((5, 5))

level_configs, custom_collection = process_cmdargs(cmdargs)

if not level_configs:
	die("No valid levels given, try --help")

level = Level()

def create_sokoban_map(map_string):
	file = io.StringIO(map_string)
	error, puzzle_type, size = parse_map_file_signature(file)
	assert not error, error
	assert puzzle_type == 'BarrelPuzzle', "Unsupported puzzle-type %s" % puzzle_type
	lines = [line.rstrip('\n') for line in file.readlines()[0:size[1]]]
	return numpy.array([list(line) for line in lines], dtype='<U1').T

def create_solver(map_string, reverse_barrel_mode=False):
	map = create_sokoban_map(map_string)
	if not quiet and show_sok:
		print(create_sok_map(map), end='')
	return create_sokoban_solver(map, reverse_barrel_mode, solution_alg, return_first, not quiet and not show_sok, show_dead, limit_time)

show_progress = quiet <= 1 and not debug.has('solv')
progress_line = ProgressLine(show_progress)

for level_index, level_config in enumerate(level_configs):
	level_index += 1
	level.set_from_config(custom_collection, level_index, level_config)
	if level.puzzle_type != 'BarrelPuzzle':
		warn("Ignoring level %d of non BarrelPuzzle type (%s)" % (level_index, level.puzzle_type))
		continue
	if level.map_string is None:
		warn("Ignoring level %d of auto-generated BarrelPuzzle, try the same in dungeon" % level_index)
		continue
	print("Solving level %d of %d: %s" % (level_index, len(level_configs), level.name))
	solver = create_solver(level.map_string, reverse_barrel_mode)
	solver.solution_type = solution_type
	solver.disable_budget = disable_budget

	def show_solution(solution_items):
		if show_time:
			print("Time: %s" % solver.last_solution_time_str)
		if not solution_items:
			print("Solution not found")
		else:
			print("Solution %s: %s" % (solver.last_solution_nums_str, solver.last_solution_str))

	try:
		while True:
			solution_items, msg = solver.find_solution_func()
			if not msg:
				break
			progress_line.put(msg)
		progress_line.put()

		show_solution(solution_items)
		print()
	except KeyboardInterrupt:
		print()
		if solver.solved_position:
			solution_items = solver.get_found_solution_items("terminated")
			show_solution(solution_items)
		print("Terminated by user. Press Enter to continue, or Ctrl-C to stop")
		try:
			sys.stdin.readline()
		except KeyboardInterrupt:
			print()
			exit(1)
