#!/usr/bin/python

import os
import sys
import numpy

sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/..')
from constants import *
from grid import grid
from test import TestSuite
from debug import debug
from teestream import stdout_redirected_to
from sokobanparser import is_sokoban_map, convert_and_pad_map_lines
from sokobansolver import *

sok_trivial_h1 = (
	'#####',
	'#@$.#',
	'#####',
)

sok_trivial_h2 = (
	' ### ',
	'#.$@#',
	' ### ',
)

sok_trivial_h3 = (
	'#####',
	'# @$.#',
	' #####',
)

sok_trivial_h4 = (
	' #####',
	'#.$ @#',
	'#####',
)

sok_trivial_v1 = (
	' #',
	'#@#',
	'#$#',
	'#.#',
	'##',
)

sok_trivial_v2 = (
	' #',
	'#.#',
	'#$#',
	'#@#',
	'##',
)

sok_trivial_s1 = (
	'#######',
	'#   ###',
	'#  $@.#',
	'# ### #',
	'#     #',
	'#######',
)

sok_trivial_s2 = (
	'#######_',
	'#--#--#_',
	'#-@$--##',
	'#--##--#',
	'##.----#',
	'_#######',
)

# 11 maps from 4x4s and 3 maps from 4x5s
sok_obvious_01 = (
	'__####',
	'__#@-#',
	'###--#',
	'#--*-#',
	'#--*-#',
	'######',
)

sok_obvious_02 = (
	'####__',
	'#-@###',
	'#-*--#',
	'#-*--#',
	'###--#',
	'__####',
)

sok_obvious_03 = (
	'__####',
	'__#-@#',
	'###--#',
	'#-*--#',
	'#---##',
	'#####_',
)

sok_obvious_04 = (
	'#####_',
	'#---##',
	'#*-*-#',
	'#@#--#',
	'#----#',
	'######',
)

sok_obvious_05 = (
	'######',
	'#----#',
	'#-$.-#',
	'##$.-#',
	'_#@-##',
	'_####_',
)

sok_obvious_06 = (
	'_#####',
	'_#.-.#',
	'###-$#',
	'#@-$-#',
	'#----#',
	'######',
)

sok_obvious_07 = (
	'######',
	'#.---#',
	'#--$-#',
	'#-#$##',
	'#.-@#_',
	'#####_',
)

sok_obvious_08 = (
	'#####_',
	'#---##',
	'#--$-#',
	'##$--#',
	'_#@..#',
	'_#####',
)

sok_obvious_09 = (
	'#####_',
	'#---##',
	'#..$-#',
	'#@$--#',
	'###--#',
	'__####',
)

sok_obvious_10 = (
	'######',
	'#----#',
	'#-#--#',
	'#@*$.#',
	'##---#',
	'_#####',
)

sok_obvious_11 = (
	'######',
	'#@*--#',
	'#-$-*#',
	'#-#--#',
	'#.---#',
	'######',
)

sok_obvious_12 = (
	'####__',
	'#-@#__',
	'#.-#__',
	'#--###',
	'#-$$-#',
	'#---.#',
	'######',
)

sok_obvious_13 = (
	'######_',
	'#-..@#_',
	'#--#$##',
	'#---$-#',
	'##----#',
	'_######',
)

sok_obvious_14 = (
	'_######',
	'_#@--.#',
	'##$#-##',
	'#-----#',
	'#-$-.-#',
	'#######',
)

sok_takaken_01 = (
	# scrambled egg
	' #####',
	' # @ ###',
	'## #$  #',
	'# *. . #',
	'#  $$ ##',
	'### #.#',
	'  #   #',
	'  #####',
)

sok_takaken_02 = (
	# a point
	'#####',
	'#   #####',
	'# # #   #',
	'# $   $ #',
	'#..#$#$##',
	'#.@$   #',
	'#..  ###',
	'######',
)

sok_takaken_03 = (
	# twins
	' ######',
	'#   $. #  #####',
	'#.$    # #    .#',
	'#### .## #.  $ #',
	' ###  #  ###  ##',
	'  ##  #   ## $#',
	'   #  #    #. #',
	'####$#######$###',
	'#       @      #',
	'################',
)

sok_takaken_04 = (
	# rescue in the bay
	'     ####',
	'   ###  ####',
	'#### $  #  #',
	'# $  $ $   #',
	'# # #$#$#  #',
	'# ....@.. ##',
	'###########',
)

sok_takaken_05 = (
	# baby classic
	'#######',
	'#...  #',
	'# # $ #',
	'#  $  #',
	'###$ ##',
	'  # @#',
	'  ####',
)

sok_takaken_06 = (
	# key
	'  #####',
	'###  @#',
	'#  $  #',
	'#    #########',
	'# #$   ....  #',
	'#  $ ######$ #',
	'##  ##    #  #',
	' ####     ####',
)

sok_takaken_07 = (
	# Love
	'   #####',
	'  ## @ #',
	'  #    #  #####    ######',
	' ##   #####   ######    #',
	'##   ##  .#   #   #  ## #',
	'# . ## $#.## *$  ## ##  #',
	'#   ##  $  # .#  #     ##',
	'#   ###    ##   ## $$#. #',
	'#  $  #  ####   ####  . #',
	'# .$  ## #  ## ##  ## ###',
	'### #### #   # #    # #',
	'  # #  # #   # #    # #',
	'### #### ##### ###### ###',
	'#                       #',
	'#########################',
)

sok_takaken_08 = (
	# rule
	'  ######',
	'###    ###',
	'#   $$ ..#',
	'# ##   # #',
	'#  ### @ #',
	'#    ##$ #',
	'# **  #  #',
	'### # # ##',
	' #  $ # #',
	' #  . #.#',
	' ###  ###',
	'   ####',
)

sok_takaken_09 = (
	# two points
	' ######',
	' #    #',
	' #$  .#',
	'## ## #',
	'#     #',
	'# $ #.##',
	'###    #',
	'  ## @ #',
	'   #####',
)

sok_takaken_10 = (
	# in a mirror
	' ########',
	' #  #   #',
	' #..#$$ #',
	' #  @   #',
	'##  #   ##',
	'#   #    #',
	'#...#$$$ #',
	'#   #    #',
	'##########',
)

sok_takaken_11 = (
	# two points again
	' #####',
	' #   ######',
	'## # @    #',
	'# . . ### #',
	'#   #$ $  #',
	'###   #   #',
	'  #########',
)

sok_takaken_12 = (
	# magic box
	'  #####',
	'### @ ###',
	'#   #   #',
	'#. ** $ #',
	'#   #   #',
	'#########',
)

sok_takaken_13 = (
	# short-sleeved shirt
	'#########',
	'#  * *  #',
	'#  $ $  #',
	'### . ###',
	'  #$.$#',
	'  # . #',
	'  # . #',
	'  #@ ##',
	'  #####',
)

sok_takaken_14 = (
	# second UFO
	'   #####',
	'   #   #',
	'   #   #',
	'####   #',
	'#  $$$ #',
	'#    # ##',
	'## ###  #',
	'#   ##  #',
	'#    #  #',
	'# ***...#',
	'###@ ####',
	'  ####',
)

sok_complex_01 = (
	# YASTGen #11 Chaos
	'--#####',
	'###@ .#',
	'# $ #.#',
	'#  $$ #',
	'#.  # #',
	'#   $.#',
	'#######',
)

sok_complex_02 = (
	# MICROCOSMOS 02
	'#################',
	'#  #  #  #  #   #',
	'#.$   #  #.$    #',
	'#  #.$ .$   #   #',
	'# @#  #  #  #   #',
	'#################',
)

optimal_solution_nums_strs = {
	sok_trivial_h1: '1/1',
	sok_trivial_h2: '1/1',
	sok_trivial_h3: '1/1',
	sok_trivial_h4: '2/1',
	sok_trivial_v1: '1/1',
	sok_trivial_v2: '1/1',
	sok_trivial_s1: ('12/2', '8/4'),
	sok_trivial_s2: ('23/3', '11/7'),
	sok_obvious_01: '17/4',
	sok_obvious_02: '18/4',
	sok_obvious_03: '19/4',
	sok_obvious_04: '24/6',
	sok_obvious_05: '28/4',
	sok_obvious_06: '30/8',
	sok_obvious_07: '32/8',
	sok_obvious_08: '33/9',
	sok_obvious_09: '35/7',
	sok_obvious_10: '42/7',
	sok_obvious_11: '43/7',
	sok_obvious_12: '39/11',
	sok_obvious_13: '45/10',
	sok_obvious_14: '64/12',
	sok_takaken_01: '170/43',
	sok_takaken_02: '185/42',
	sok_takaken_03: '0/0',
	sok_takaken_04: ('256/67', '250/69'),
	sok_takaken_05: '84/24',
	sok_takaken_06: ('180/52', '172/56'),
	sok_takaken_07: '0/0',
	sok_takaken_08: '191/41',
	sok_takaken_09: '93/16',
	sok_takaken_10: '0/0',
	sok_takaken_11: '105/22',
	sok_takaken_12: '86/19',
	sok_takaken_13: ('213/54', '207/58'),
	sok_takaken_14: '0/0',
	sok_complex_01: ('171/42', '170/42'),  # '144/38',
	sok_complex_02: ('265/88', '265/88'),  # '211/82',
}

optimal_solution_nums_strs_by_type = {
	SOLUTION_TYPE_BY_SHIFTS: {k: v[0] if type(v) == tuple else v for k, v in optimal_solution_nums_strs.items()},
	SOLUTION_TYPE_BY_MOVES:  {k: v[1] if type(v) == tuple else v for k, v in optimal_solution_nums_strs.items()},
}

optimal_solution_strs = {
	sok_trivial_h1: 'R',
	sok_trivial_h2: 'L',
	sok_trivial_h3: 'R',
	sok_trivial_h4: 'lL',
	sok_trivial_v1: 'D',
	sok_trivial_v2: 'U',
	sok_trivial_s1: ('rddlllluurRR', 'LulldRRR'),
	sok_trivial_s2: ('ddrrruulLrrddllluluurDD', 'RRurDDrdLLL'),
	sok_obvious_01: 'rdddLUlldRurruulD',
	sok_obvious_02: 'lddRluurDrrddlUruL',
	sok_obvious_03: 'ldddlluRdrUruulDrdL',
	sok_obvious_04: 'drruruLullDRurDrddlUdllU',
	sok_obvious_05: 'ruuulldRurrddldlUrruulDulldR',
	sok_obvious_06: 'rdrruLuurDlddlluRdrUUruLdddrUU',
	sok_obvious_07: 'lluuurrrdLulldddrrUULulDDurrruLL',
	sok_obvious_08: 'ruruLulldRurDrddllURuulldRurDDurD',
	sok_obvious_09: 'uurrDrddlUruLullddRluurrdLrrddlUruL',
	sok_obvious_10: 'uurrrdddlUruulllddRRlluurrDullddrdrrULuurD',
	sok_obvious_11: 'dddrruuurDlddlluuuRldddrruuLulDDurrruLdddrU',
	sok_obvious_12: 'lddddrUUddrruLdlluurDuluurDDlddRRuLdlUU',
	sok_obvious_13: 'llddrdrruLLdlUluurrrDulllddrUluRddrdrruLLdlUU',
	sok_obvious_14: 'rrddllldRRuruullDurrddldlluRuurrddrdLLruuullddRdrUUdllldRRuluurR',
	sok_complex_01: 'dDuurrddLLrrddLLUlluuRDRddrruuLLrruullDlldddRRuULrrruullDldRddlUruuurrddddLLuuRlddrruUUdlldlldRRuuulDrddlluRurrrddLLUluRRlddrruUllldldRRRluuullD',
	sok_complex_02: 'uluurDrrddrUrrRRRuRRRurrdLulDlllddrUllllllluurDllllddrUluRRRdRRRRRRuRRRurDllllddrUluRRRurrdLLLLulDrdLLLdlUllluurDldRRRRRRdrUluRRRurrdLLLLulDrrrrrddlUruLLLLdLLLLLLdlUrrrrrrruulDrrrrddlUruLLLdLLLLLLuLLLrrrdrrruulD',
}

optimal_solution_strs_by_type = {
	SOLUTION_TYPE_BY_SHIFTS: {k: v[0] if type(v) == tuple else v for k, v in optimal_solution_strs.items()},
	SOLUTION_TYPE_BY_MOVES:  {k: v[1] if type(v) == tuple else v for k, v in optimal_solution_strs.items()},
}

verbose = False
def print_if_verbose(*args):
	if verbose:
		print(INFO_PREFIX, end='')
		print(*args)

def create_sokoban_map(lines):
	assert is_sokoban_map(lines), "Invalid Sokoban map:\n%s" % '\n'.join(lines)
	return numpy.array([list(line) for line in convert_and_pad_map_lines(lines)], dtype='<U1').T

def create_solver(sokoban_map_lines, reverse_barrel_mode=False, solution_alg=None, return_first=False):
	map = create_sokoban_map(sokoban_map_lines)
	return create_sokoban_solver(map, reverse_barrel_mode, solution_alg, return_first, "Created solver for map" if verbose else False)

def test_solution(sok, unique_solution_str=False, solution_alg=None, return_first=False):
	for solution_type in SOLUTION_TYPE_BY_SHIFTS, SOLUTION_TYPE_BY_MOVES:
		solver = create_solver(sok, False, solution_alg, return_first)
		solution_items = solver.solve(solution_type)
		test.not_none(solution_items)
		test.eq(solver.last_solution_nums_str, optimal_solution_nums_strs_by_type[solution_type][sok])
		if unique_solution_str:
			test.eq(solver.last_solution_str, optimal_solution_strs_by_type[solution_type][sok])
		else:
			test.ne(solver.last_solution_str, '')

def test_no_solution(sok):
	solver = create_solver(sok)
	solution_items = solver.solve()
	test.none(solution_items)
	test.none(solver.last_solution_nums_str)
	test.none(solver.last_solution_str)

def test_trivial_solutions():
	for sok in sok_trivial_h1, sok_trivial_h2, sok_trivial_h3, sok_trivial_h4, sok_trivial_v1, sok_trivial_v2, sok_trivial_s1, sok_trivial_s2:
		test_solution(sok, True)

def test_obvious_solutions():
	for sok in sok_obvious_01, sok_obvious_02, sok_obvious_03, sok_obvious_04, sok_obvious_05, sok_obvious_06, sok_obvious_07, sok_obvious_08, sok_obvious_09, sok_obvious_10, sok_obvious_11, sok_obvious_12, sok_obvious_13, sok_obvious_14:
		test_solution(sok, True)

def test_takaken_solutions():
	for sok in sok_takaken_01, sok_takaken_05, sok_takaken_09, sok_takaken_11, sok_takaken_12:
		test_solution(sok)

def test_complex_solutions():
	for sok in sok_complex_01, sok_complex_02:
		test_solution(sok, False, SOLUTION_ALG_ASTAR, True)

def test_trivial_without_solutions():
	# already solved trivial map; unsolvable, since needs at least one shift
	test_no_solution((
		'#####',
		'#@* #',
		'#####',
	))
	# another circular unsolvable
	test_no_solution((
		'#####',
		'#@* #',
		'# * #',
		'#####',
	))
	# barrel on dead-barrel-cell
	test_no_solution((
		'#####',
		'#@$ #',
		'#  .#',
		'#####',
	))
	# deadlock
	test_no_solution((
		'#####',
		'#@$.#',
		'#.$ #',
		'#####',
	))

def test_algorithms_consistency():
	for sok in sok_trivial_h3, sok_obvious_05, sok_obvious_06:
		for reverse_barrel_mode in False, True:
			results = {}
			for alg in SOLUTION_ALG_DFS, SOLUTION_ALG_BFS, SOLUTION_ALG_GREED, SOLUTION_ALG_ASTAR:
				# solve both types
				solver = create_solver(sok, reverse_barrel_mode)
				solver.solution_alg = alg
				sol_s = solver.solve(SOLUTION_TYPE_BY_SHIFTS)
				results[(alg, 'shifts')] = solver.last_solution_nums_str
				# reconfigure fresh
				solver = create_solver(sok, reverse_barrel_mode)
				solver.solution_alg = alg
				sol_m = solver.solve(SOLUTION_TYPE_BY_MOVES)
				results[(alg, 'moves')] = solver.last_solution_nums_str
				test.eq(sol_s, sol_m)
			# all values must match BFS results
			base_shifts = results[(SOLUTION_ALG_BFS, 'shifts')]
			base_moves  = results[(SOLUTION_ALG_BFS, 'moves')]
			for k, v in results.items():
				if k[1] == 'shifts':
					test.eq(v, base_shifts)
				else:
					test.eq(v, base_moves)

def test_reparent_dirty_propagation():
	sok = sok_trivial_s1
	solver = create_solver(sok)
	solver.solution_alg = SOLUTION_ALG_BFS
	# prepare and create the initial structures
	solver.prepare_solution(solver.char_cell)
	grid.set_barrels(solver.barrel_cells)
	super_position = solver.find_or_create_super_position(grid.to_idx(solver.char_cell))
	position = Position(super_position, solver.char_cell, None, None, None)
	# create a fake child and reparent to check propagation
	child = Position(super_position, solver.char_cell, position, (3, 1), [([], solver.char_cell, solver.barrel_cells[0])])
	# now reparent child to position again with different own_nums
	child.reparent(position, (1, 1), child.segments)
	# after reparent, child's total_nums and depth must reflect new parent
	test.eq(child.parent, position)
	test.eq(child.is_dirty, True)
	test.eq(child.is_fully_processed, False)

def test_prepare_solution_without_plates():
	sok = ('#######', '# @ $ #', '#######')
	solver = create_solver(sok)
	solver.prepare_solution()
	test.has_attr(grid, 'dead_barrel_bits')
	test.has_attr(solver, 'min_barrel_costs')
	test.has_attr(solver, 'min_char_barrel_costs')
	test.has_attr(solver, 'min_plate_barrel_costs')
	test.has_attr(solver, 'min_plate_char_barrel_costs')
	# ensure all floor cells are marked as dead without plates
	num_dead_barrel_bits = grid.dead_barrel_bits.count()
	test.gt(num_dead_barrel_bits, 0)
	test.eq(num_dead_barrel_bits, grid.num_bits)

def test_prepare_solution_with_plate():
	solver = create_solver(sok_obvious_10)
	solver.prepare_solution()
	dead_barrel_bits = grid.dead_barrel_bits
	test.gt(dead_barrel_bits.count(), 0)
	# now call with disable_prepare=True
	solver.disable_prepare = True
	solver.prepare_solution()
	# when disabled, dead_barrel_bits is no_bits
	test.eq(grid.dead_barrel_bits.count(), 0)
	# chech consistency
	solver.disable_prepare = False
	solver.prepare_solution()
	test.eq(grid.dead_barrel_bits, dead_barrel_bits)

def test_prepare_solution_char_filtering():
	solver = create_solver(sok_trivial_s2)
	# call prepare with char set vs char None and observe dead_barrel_bits differs or min_shifts differs
	solver.prepare_solution(None)
	all_dead_count = grid.dead_barrel_bits.count()
	# now restrict by char position: recompute
	solver.prepare_solution(solver.char_cell)
	char_dead_count = grid.dead_barrel_bits.count()
	# reachable plates only should reduce dead set (or stay equal) â€” expect char_dead_count <= all_dead_count
	test.le(char_dead_count, all_dead_count)

def test_superposition_idempotence():
	solver = create_solver(sok_trivial_h1)
	solver.prepare_solution(solver.char_cell)
	# create two barrel lists with same set but different order
	barrel_cells = tuple(solver.barrel_cells)
	grid.set_barrels(barrel_cells)
	sp1 = solver.find_or_create_super_position(solver.char_cell)
	grid.set_barrels(reversed(barrel_cells))
	sp2 = solver.find_or_create_super_position(solver.char_cell)
	test.eq(sp1, sp2)

def test_position_num_calculation():
	solver = create_solver(sok_trivial_h1)
	solver.prepare_solution(solver.char_cell)
	grid.set_barrels(solver.barrel_cells)
	char_idx = grid.to_idx(solver.char_cell)
	super_pos = solver.find_or_create_super_position(char_idx)
	root = Position(super_pos, char_idx, None, None, None)
	child = Position(super_pos, char_idx, root, (3, 2), [])
	test.eq(child.total_nums, (3, 2))
	# Reparent child with new own_nums
	child.reparent(root, (1, 1), [])
	test.eq(child.total_nums, (3, 2))

def test_find_solution_status_string():
	solver = create_solver(sok_trivial_h2)
	solver.unprocessed_positions = []
	solver.start_solution_time = time()
	status = solver.get_find_solution_status_str()
	test.is_in('positions', status)
	test.is_in('Finding', status)

args = sys.argv[1:]
verbose = args.count('-v') >= 2
if args.count('-v') >= 3:
	debug.configure(['solv' + ('+' * (args.count('-v') - 3))])
test = TestSuite("SokobanSolver", '-a' in args, '-v' in args, '-p' in args)
try:
	test_trivial_solutions()
	test_obvious_solutions()
	test_takaken_solutions()
	test_complex_solutions()
	test_trivial_without_solutions()
	test_algorithms_consistency()
	test_reparent_dirty_propagation()
	test_prepare_solution_without_plates()
	test_prepare_solution_with_plate()
	test_prepare_solution_char_filtering()
	test_superposition_idempotence()
	test_position_num_calculation()
	test_find_solution_status_string()
	test.finalize()
except KeyboardInterrupt:
	print()
	test.ok(False, "Tests terminated by user")
	test.finalize()
