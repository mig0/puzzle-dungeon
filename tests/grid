#!/usr/bin/python

import os
import sys
import numpy
from bitarray import bitarray

sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/..')
from constants import *
from grid import Grid
from test import TestSuite
from celltools import cell_distance
from teestream import stdout_redirected_to

verbose = False
def print_if_verbose(*args):
	if verbose:
		print(INFO_PREFIX, end='')
		print(*args)

def show_map_if_verbose(grid, descr):
	if verbose:
		grid.show_map(descr)

def make_empty_map(width, height):
	return numpy.full((width, height), CELL_FLOOR)

def make_empty_map_with_wall_border(width, height):
	map = make_empty_map(width, height)
	map[ 0,  :] = CELL_WALL
	map[-1,  :] = CELL_WALL
	map[ :,  0] = CELL_WALL
	map[ :, -1] = CELL_WALL
	return map

def make_empty_zsb_map(zsb_size_x, zsb_size_y):
	map = make_empty_map(zsb_size_x * 2 + 1, zsb_size_y * 2 + 1)
	for y in range(zsb_size_y):
		for x in range(zsb_size_x):
			map[x * 2 + 1, y * 2 + 1] = CELL_WALL
	return map

def make_empty_zsb_map_with_wall_border(zsb_size_x, zsb_size_y):
	map = make_empty_map_with_wall_border(zsb_size_x * 2 + 3, zsb_size_y * 2 + 3)
	for y in range(zsb_size_y):
		for x in range(zsb_size_x):
			map[x * 2 + 2, y * 2 + 2] = CELL_WALL
	return map

def make_simple_map():
	lines = [
		# sample 7x6 layout
		"·▓▓▓▓▓▓·",
		"▓••••••▓",
		"▓•▓•▓••▓",
		"▓••••••▓",
		"▓•••▓••▓",
		"▓••••••▓",
		"▓▓▓▓▓▓▓·",
	]
	return numpy.array([list(line) for line in lines], dtype='<U1').T

def make_simple_zsb_map():
	lines = [
		# sample zsb 3x3 layout
		"▓▓▓▓▓▓▓▓▓",
		"▓•••••••▓",
		"▓•▓□▓⎵▓•▓",
		"▓•⎵•■•□•▓",
		"▓•▓■▓■▓•▓",
		"▓•□•⎵•■•▓",
		"▓•▓⎵▓□▓•▓",
		"▓•••••••▓",
		"▓▓▓▓▓▓▓▓▓",
	]
	return numpy.array([list(line) for line in lines], dtype='<U1').T

def configure_simple_grid(reverse_barrel_mode=False, plate_cells=None, show_map=False):
	game_map = make_simple_map()
	for plate_cell in plate_cells or []:
		game_map[plate_cell] = CELL_PLATE
	grid = Grid()
	grid.configure(game_map, reverse_barrel_mode=reverse_barrel_mode)
	if show_map:
		show_map_if_verbose(grid, "Simple grid")
	return grid

def configure_simple_zsb_grid(reverse_barrel_mode=False, show_map=False):
	game_map = make_simple_zsb_map()
	grid = Grid()
	grid.configure(game_map, reverse_barrel_mode=reverse_barrel_mode)
	if show_map:
		show_map_if_verbose(grid, "Simple ZSB grid")
	return grid

def test_get_accessible_cells():
	grid = configure_simple_grid()

	start_cell = (1, 1)
	corner_cell = (6, 5)
	wall_cell = (2, 2)
	accessible_cells = grid.get_accessible_cells(start_cell)
	test.eq(type(accessible_cells), tuple)
	test.is_in(start_cell, accessible_cells)
	test.is_in(corner_cell, accessible_cells)
	test.not_in(wall_cell, accessible_cells)

	show_map_if_verbose(grid, "Map after test_get_accessible_cells")

def test_get_accessible_distance():
	grid = configure_simple_grid()
	test.eq(grid.get_accessible_distance((1, 1), (3, 1)), 2)
	test.eq(grid.get_accessible_distance((3, 1), (1, 1)), 2)
	test.eq(grid.get_accessible_distance((1, 1), (3, 3)), 4)
	test.eq(grid.get_accessible_distance((3, 3), (1, 1)), 4)
	test.eq(grid.get_accessible_distance((3, 3), (6, 5)), 5)
	test.eq(grid.get_accessible_distance((6, 5), (3, 3)), 5)
	test.eq(grid.get_accessible_distance((1, 1), (6, 5)), 9)
	test.eq(grid.get_accessible_distance((6, 5), (1, 1)), 9)
	# idxs
	test.eq(grid.get_accessible_distance(0, 7), 3)
	test.eq(grid.get_accessible_distance(7, 8), 4)
	# same cell
	test.eq(grid.get_accessible_distance((5, 5), (5, 5)), 0)
	test.none(grid.get_accessible_distance((7, 7), (7, 7)))
	# unreachable cell
	test.none(grid.get_accessible_distance((1, 1), (1, 0)))
	test.none(grid.get_accessible_distance((3, 3), (5, 6)))

	grid.set_barrels([(3, 3)])
	# path that would go through barrel should be blocked
	test.eq(grid.get_accessible_distance((1, 1), (4, 3)), 7)
	test.eq(grid.get_accessible_distance((1, 1), (4, 3), grid.barrel_bits), 7)
	test.eq(grid.get_accessible_distance((1, 1), (6, 5)), 9)
	test.eq(grid.get_accessible_distance((1, 1), (6, 5), [(1, 2), (3, 2), (5, 4), (6, 4)]), 13)
	test.none(grid.get_accessible_distance((1, 1), (6, 5), ((4, 5), (5, 4), (6, 4))))
	test.none(grid.get_accessible_distance((1, 1), (3, 3)))
	test.eq(grid.get_accessible_distance(2, 13, [(3, 2)]), 5)

def test_get_accessible_distances():
	grid = configure_simple_grid()

	start_cell = (1, 1)
	floor_cell = (5, 5)
	wall_cell = (2, 2)
	distances = grid.get_accessible_distances(start_cell)
	test.eq(type(distances), numpy.ndarray)
	if start_cell in grid.cell_idxs:
		test.eq(distances[grid.cell_idxs[start_cell]], 0)
	if floor_cell in grid.cell_idxs:
		test.gt(distances[grid.cell_idxs[floor_cell]], 0)

	cell_distances = grid.get_accessible_cell_distances(start_cell)
	test.eq(type(cell_distances), dict)
	test.is_in(start_cell, cell_distances)
	test.is_in(floor_cell, cell_distances)
	test.not_in(wall_cell, cell_distances)
	test.eq(cell_distances.get(start_cell), 0)
	test.eq(cell_distances.get(floor_cell), 8)

	show_map_if_verbose(grid, "Map after test_get_accessible_distances")

def test_find_path():
	grid = configure_simple_grid()

	start_cell = (1, 1)
	target_cell = (5, 5)
	path_cells = grid.find_path(start_cell, target_cell)
	test.not_none(path_cells)
	# find_path semantics: excludes start cell, but includes target cell
	if path_cells:
		test.not_in(start_cell, path_cells)
		test.eq(path_cells[-1], target_cell)

	# check adjacency of consecutive steps
	for i in range(len(path_cells) - 1):
		cell1, cell2 = path_cells[i], path_cells[i + 1]
		cell1_idx = grid.cell_idxs[cell1]
		neigh_idxs = grid.all_passable_neigh_idxs[cell1_idx]
		neigh_cells = grid.to_cells(neigh_idxs)
		test.is_in(cell2, neigh_cells)

	start_cell = (2, 1)
	target_cell = (5, 2)
	target_idx = grid.cell_idxs.get(target_cell)
	test.not_none(target_idx)
	if target_idx is not None:
		path_cells = grid.get_accessible_distances(start_cell)
		print_if_verbose(start_cell, target_cell, path_cells)
		test.eq(path_cells[target_idx], 4)

	show_map_if_verbose(grid, "Map after test_find_path")

def test_barrel_op(grid, name, char_cell, barrel_cell, expected_to_pass):
	op = getattr(grid, name)
	new_cells = op(char_cell, barrel_cell)
	if expected_to_pass:
		test.not_none(new_cells)
	else:
		test.none(new_cells)
	if new_cells:
		new_char_cell, new_barrel_cell = new_cells
		test.is_cell(new_char_cell)
		test.is_cell(new_barrel_cell)
		# chech whether barrel_bits are shifted
		must_change = not name.startswith("try_")
		test.eq(grid.barrel_bits[grid.cell_idxs[barrel_cell]], not must_change)
		test.eq(grid.barrel_bits[grid.cell_idxs[new_barrel_cell]], must_change)

def test_barrel_three_ops(grid, name, char_cell, barrel_cell, expected_to_pass):
	can_op = getattr(grid, "can_" + name)
	if expected_to_pass:
		test.ok(can_op(char_cell, barrel_cell), "Can't %s %s -> %s" % (name, char_cell, barrel_cell))
	else:
		test.ok(not can_op(char_cell, barrel_cell), "Can %s %s -> %s" % (name, char_cell, barrel_cell))
	test_barrel_op(grid, "try_" + name, char_cell, barrel_cell, expected_to_pass)
	test_barrel_op(grid,          name, char_cell, barrel_cell, expected_to_pass)

def test_add_barrel_and_three_ops(grid, name, char_cell, barrel_cell, expected_to_pass):
	existing_barrel_cells = grid.barrel_cells
	grid.store_reset_barrels()

	grid.set_barrels(existing_barrel_cells + (barrel_cell,))
	test.ok(grid.barrel_bits[grid.cell_idxs[barrel_cell]], "No barrel bit at %s" % (barrel_cell,))

	test_barrel_three_ops(grid, name, char_cell, barrel_cell, expected_to_pass)

	grid.restore_barrels()

def test_add_barrel_and_all_ops(grid, name, char_cell, barrel_cell, expected_to_pass):
	show_map_if_verbose(grid, "Map before test_barrel_and_shift_ops %s %s -> %s %s" % (name, char_cell, barrel_cell, expected_to_pass))
	test_add_barrel_and_three_ops(grid, name,    char_cell, barrel_cell, expected_to_pass)
	test_add_barrel_and_three_ops(grid, "shift", char_cell, barrel_cell, expected_to_pass)

def test_push_pull_shift():
	# forward (push) mode
	grid = configure_simple_grid()
	test_add_barrel_and_all_ops(grid, "push", (1, 4), (2, 4), True)
	test_add_barrel_and_all_ops(grid, "push", (4, 3), (3, 3), True)
	grid.set_barrels([(1, 2), (1, 3), (5, 4)])
	test_add_barrel_and_all_ops(grid, "push", (1, 4), (2, 4), True)
	test_add_barrel_and_all_ops(grid, "push", (4, 3), (3, 3), False)  # 2x2 deadlock
	test_add_barrel_and_all_ops(grid, "push", (5, 2), (5, 3), False)  # blocking barrel
	test_add_barrel_and_all_ops(grid, "push", (5, 5), (5, 4), True)
	grid.set_barrels([(4, 1), (1, 3), (3, 4)])
	test_add_barrel_and_all_ops(grid, "push", (1, 4), (2, 4), False)  # blocking barrel
	test_add_barrel_and_all_ops(grid, "push", (4, 3), (3, 3), True)
	test_add_barrel_and_all_ops(grid, "push", (5, 2), (5, 3), True)
	test_add_barrel_and_all_ops(grid, "push", (5, 5), (5, 4), True)
	test_barrel_three_ops(      grid, "push", (5, 5), (5, 4), False)  # no barrel

	# reverse (pull) mode: configure a new Grid in reverse mode
	grid = configure_simple_grid(reverse_barrel_mode=True)
	test_add_barrel_and_all_ops(grid, "pull", (2, 4), (3, 4), True)
	test_add_barrel_and_all_ops(grid, "pull", (4, 1), (5, 1), True)
	grid.set_barrels([(1, 3), (1, 5), (5, 5)])
	test_add_barrel_and_all_ops(grid, "pull", (2, 4), (3, 4), False)  # surrounding deadlock
	test_add_barrel_and_all_ops(grid, "pull", (4, 1), (5, 1), True)
	test_add_barrel_and_all_ops(grid, "pull", (5, 4), (5, 3), False)  # blocking barrel
	test_add_barrel_and_all_ops(grid, "pull", (5, 4), (5, 5), True)
	grid.set_barrels([(1, 3), (1, 5), (1, 4)])
	test_add_barrel_and_all_ops(grid, "pull", (2, 4), (3, 4), False)  # blocking barrel
	test_add_barrel_and_all_ops(grid, "pull", (4, 1), (5, 1), True)
	test_add_barrel_and_all_ops(grid, "pull", (5, 4), (5, 3), True)
	test_add_barrel_and_all_ops(grid, "pull", (5, 4), (5, 5), True)
	test_barrel_three_ops(      grid, "pull", (5, 4), (5, 5), False)  # no barrel

	show_map_if_verbose(grid, "Map after test_push_pull_shift")

def test_all_valid_shifts_consistency():
	grid = configure_simple_grid()

	char_cell = (2, 3)
	grid.set_barrels([(3, 3), (4, 3)])
	accessible_bits = grid.get_accessible_bits(char_cell)
	cell_pairs = grid.get_all_valid_char_barrel_shifts(accessible_bits)

	test.ok(cell_pairs, "Should find at least one shift")
	test.len(cell_pairs, 2)
	for char_cell, barrel_cell in cell_pairs:
		# ensure these pairs are consistent
		test.ok(grid.can_shift(char_cell, barrel_cell), "Can't really shift %s -> %s" % (char_cell, barrel_cell))
		test.eq(barrel_cell, (3, 3))

	grid.set_barrels([(2, 4)])
	accessible_bits = grid.get_accessible_bits(char_cell)
	cell_pairs = grid.get_all_valid_char_barrel_shifts()
	test.len(cell_pairs, 4)
	for char_cell, barrel_cell in cell_pairs:
		test.eq(cell_distance(char_cell, barrel_cell), 1)
		test.eq(barrel_cell, (2, 4))

	show_map_if_verbose(grid, "Map after test_all_valid_shifts_consistency")

def test_store_and_restore_barrels():
	grid = configure_simple_grid()

	barrel_cells = [(2, 3), (4, 3)]
	grid.set_barrels(barrel_cells)
	barrel_bits_before = grid.barrel_bits.copy()

	grid.store_barrels()
	# check that store_barrels does not modify barrel_bits
	test.eq(grid.barrel_bits, barrel_bits_before)
	grid.barrel_bits.setall(False)
	grid.restore_barrels()

	# bitarray equality check: no differing bits
	test.eq(grid.barrel_bits, barrel_bits_before)

	grid.store_reset_barrels()
	# check that store_reset_barrels resets barrel_bits
	test.ne(grid.barrel_bits, barrel_bits_before)
	test.eq(grid.barrel_bits, grid.no_bits)
	grid.barrel_bits.setall(True)
	grid.restore_barrels()

	# bitarray equality check: no differing bits
	test.eq(grid.barrel_bits, barrel_bits_before)

	show_map_if_verbose(grid, "Map after test_store_and_restore_barrels")

def test_large_open_area_performance():
	w, h = 40, 20
	game_map = make_empty_map_with_wall_border(w, h)
	grid = Grid()
	grid.configure(game_map)
	accessible_bits = grid.get_accessible_bits((1, 1))
	test.eq(accessible_bits.count(), (w - 2) * (h - 2))
	accessible_bits = grid.get_accessible_bits((3, 3))
	test.eq(accessible_bits.count(), (w - 2) * (h - 2))
	path_cells = grid.find_path((1, 1), (w - 2, h - 2))
	test.not_none(path_cells)
	test.len(path_cells, (w - 3) + (h - 3))

	show_map_if_verbose(grid, "Map after test_large_open_area_performance")

def test_deadlock_detection():
	grid = configure_simple_grid()
	# Set up a 2x2 block of barrels — should trigger 2x2 deadlock
	grid.set_barrels([(3, 2), (3, 3), (4, 3)])
	show_map_if_verbose(grid, "Map before 2x2 deadlock")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((5, 2), DIR_U), "Unexpected 2x2 deadlock #1 detected")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((3, 3), DIR_D), "Unexpected 2x2 deadlock #2 detected")
	test.ok(    grid.is_r_or_l_2x2_barrel_deadlock((3, 4), DIR_R), "Expected 2x2 deadlock #1 not detected")
	test.ok(    grid.is_r_or_l_2x2_barrel_deadlock((3, 4), DIR_U), "Expected 2x2 deadlock #2 not detected")
	test.ok(    grid.is_r_or_l_2x2_barrel_deadlock((2, 3), DIR_U), "Expected 2x2 deadlock #3 not detected")

	for plate_cell, res in [(3, 4), True], [(3, 3), True], [(4, 3), False]:
		grid.plate_bits[grid.to_idx(plate_cell)] = True
		test.ok(grid.is_r_or_l_2x2_barrel_deadlock((3, 4), DIR_R) is res, f"Unexpected 2x2 deadlock with plate {plate_cell} detected")

	# Set up barrel on plate for the next 3 reconfigure
	grid.map[(1, 3)] = ACTOR_ON_PLATE_CHARS['barrel']

	grid.map[(1, 2)] = CELL_WALL
	grid.reconfigure()
	show_map_if_verbose(grid, "Map before X1 +wall 2x2 deadlock")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((5, 2), DIR_U), "X1: Unexpected 2x2 deadlock #1 detected")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((3, 4), DIR_R), "X1: Unexpected 2x2 deadlock #2 detected")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((1, 3), DIR_U), "X1: Unexpected 2x2 deadlock #3 detected")
	test.ok(    grid.is_r_or_l_2x2_barrel_deadlock((2, 3), DIR_U), "X1: Expected 2x2 deadlock #1 not detected")
	test.ok(    grid.is_r_or_l_2x2_barrel_deadlock((1, 1), DIR_L), "X1: Expected 2x2 deadlock #2 not detected")

	grid.map[(3, 3)] = CELL_WALL
	grid.reconfigure()
	show_map_if_verbose(grid, "Map before X2 +wall 2x2 deadlock")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((5, 2), DIR_U), "X2: Unexpected 2x2 deadlock #1 detected")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((3, 4), DIR_R), "X2: Unexpected 2x2 deadlock #2 detected")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((1, 3), DIR_U), "X2: Unexpected 2x2 deadlock #3 detected")
	test.ok(    grid.is_r_or_l_2x2_barrel_deadlock((2, 3), DIR_U), "X2: Expected 2x2 deadlock #1 not detected")
	test.ok(    grid.is_r_or_l_2x2_barrel_deadlock((1, 1), DIR_L), "X2: Expected 2x2 deadlock #2 not detected")

	grid.map[(2, 3)] = CELL_PLATE
	grid.reconfigure()
	show_map_if_verbose(grid, "Map before X3 +plate 2x2 deadlock")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((5, 2), DIR_U), "X3: Unexpected 2x2 deadlock #1 detected")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((3, 4), DIR_R), "X3: Unexpected 2x2 deadlock #2 detected")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((1, 3), DIR_U), "X3: Unexpected 2x2 deadlock #3 detected")
	test.ok(not grid.is_r_or_l_2x2_barrel_deadlock((2, 3), DIR_U), "X3: Unexpected 2x2 deadlock #4 detected")
	test.ok(    grid.is_r_or_l_2x2_barrel_deadlock((1, 1), DIR_L), "X3: Expected 2x2 deadlock #1 not detected")

	# Set up a character surrounded by walls/barrels (pull mode)
	grid = configure_simple_grid(reverse_barrel_mode=True)
	grid.set_barrels([(3, 2), (2, 3), (3, 4)])
	show_map_if_verbose(grid, "Map before surrounding deadlock")
	test.ok(not grid.is_surrounding_barrel_deadlock((3, 3), (2, 3), DIR_R), "Unexpected surrounding deadlock detected")
	test.ok(    grid.is_surrounding_barrel_deadlock((3, 3), (3, 4), DIR_L), "Expected surrounding deadlock not detected")

def test_find_path_with_barrels():
	grid = configure_simple_grid()
	grid.set_barrels([(3, 3)])
	start, target = (1, 1), (5, 5)
	path_cells = grid.find_path(start, target, grid.barrel_cells)
	test.not_none(path_cells)
	# Ensure path avoids the barrel
	test.not_in((3, 3), path_cells)

def test_reverse_mode_consistency():
	for reverse in (False, True):
		grid = configure_simple_grid(reverse_barrel_mode=reverse)
		grid.set_barrels([(3, 3)])
		char, barrel = (2, 3), (3, 3)
		can_shift = grid.can_shift(char, barrel)
		test.is_instance(can_shift, bool)
		if can_shift:
			new_cells = grid.shift(char, barrel)
			test.not_none(new_cells)
			new_char_cell, new_barrel_cell = new_cells
			test.ne(new_char_cell, char)
			test.ne(new_barrel_cell, barrel)

def test_bit_integrity():
	grid = configure_simple_grid()
	grid.set_barrels([(2, 3), (4, 3)])
	grid.store_barrels()
	grid.restore_barrels()
	test.eq(grid.barrel_bits.count(), 2)
	grid.store_reset_barrels()
	test.eq(grid.barrel_bits.count(), 0)
	grid.restore_barrels()
	test.eq(grid.barrel_bits.count(), 2)
	# check some basic bit ops and that it returns bits copy
	bits = grid.to_bits([1, 2])
	bito = grid.to_bit(1) | grid.to_bit(2)
	test.eq(bits, bito)
	bits.setall(True)
	test.ne(bits, grid.no_bits)
	test.eq(bits, grid.all_bits)
	test.ne(bits, bito)
	test.eq(bito & bits, bito)
	bits.setall(False)
	test.eq(bits, grid.no_bits)
	test.ne(bits, grid.all_bits)
	test.ne(bits, bito)
	test.eq(bito & bits, grid.no_bits)

def test_find_path_edge_cases():
	grid = configure_simple_grid()
	# identical start/target
	start = target = (1, 1)
	path = grid.find_path(start, target)
	test.eq(path, ())
	# unreachable target (enclosed by walls)
	unreachable = (0, 0)
	path = grid.find_path(start, unreachable)
	test.none(path)

def test_conversion_helpers():
	grid = configure_simple_grid()
	# to_bits / to_idxs / to_cells round-trip
	cells = [(1, 1), (2, 1), (3, 1)]
	bits = grid.to_bits(cells)
	idxs = grid.to_idxs(bits)
	cells2 = grid.to_cells(bits)
	test.eq(type(bits), type(grid.no_bits))
	test.eq(type(idxs), tuple)
	test.eq(type(cells2), tuple)
	test.eq(cells2, tuple(cells))
	# to_idx_or_none for invalid cell returns None
	test.none(grid.to_idx_or_none((-1, -1)))
	# to_idx for an actor-like object: emulate class with .c attribute
	class CellActor:
		def __init__(self, c): self.c = c
	fa = CellActor((1, 1))
	test.eq(grid.to_idx(fa), grid.to_idx((1, 1)))

def test_show_map_no_crash():
	grid = configure_simple_grid()
	# ensure show_map doesn't raise when there are void/wall cells
	try:
		streams = (sys.stdout,) if verbose else ()
		with stdout_redirected_to(*streams):
			grid.show_map("Smoke test show_map", show_dead=True)
	except Exception as e:
		test.ok(False, "show_map raised exception: %s" % (e,))
	else:
		test.ok(True, "show_map executed without exception")

def test_set_barrels_wall_raises():
	grid = configure_simple_grid()
	wall_cell = (0, 0)  # corner of layout is wall or void in map
	# set_barrels uses to_bits -> to_idx -> KeyError for wall cells: expect exception
	try:
		grid.set_barrels([wall_cell])
	except KeyError:
		test.ok(True, "Expected KeyError when setting a wall as barrel")
	except Exception as e:
		test.ok(False, "Expected KeyError, got %s" % (e,))
	else:
		test.ok(False, "Expected exception when setting a wall as barrel, but none raised")

def test_last_accessible_bits_and_obstacles():
	grid = configure_simple_grid()
	start = (1, 1)
	# no obstacles: accessible_bits should include many cells
	bits = grid.get_accessible_bits(start)
	test.eq(bits, grid.last_accessible_bits)
	test.gt(bits.count(), 1)
	# set a barrel and pass it as obstacle to get_accessible_bits -> returned bits exclude that cell
	obstacle = (3, 3)
	grid.set_barrels([obstacle])
	bits_with_barrel = grid.get_accessible_bits(start, obstacles=grid.barrel_bits)
	test.lt(bits_with_barrel.count(), bits.count())
	test.eq(grid.barrel_bits.count(), 1)
	test.ok(not bits_with_barrel[grid.to_idx(obstacle)], "accessible_bits should exclude obstacle cell")
	# calling get_accessible_cells with obstacles param
	cells = grid.get_accessible_cells(start, obstacles=(obstacle,))
	test.not_in(obstacle, cells)

def test_try_push_pull_without_barrel():
	grid = configure_simple_grid()
	char_cell, barrel_cell = (2, 3), (3, 3)
	# ensure no barrel present at barrel cell
	grid.store_reset_barrels()
	# try_push/try_pull should return None when there is no barrel at barrel_cell
	test.none(grid.try_push(char_cell, barrel_cell))
	test.none(grid.try_pull(char_cell, barrel_cell))
	# same for try_shift (depending on reverse mode)
	test.none(grid.try_shift(char_cell, barrel_cell))
	grid.restore_barrels()

def test_zsb_area_size_validation():
	grid = Grid()
	grid.configure(make_empty_map(11, 11))  # 11x11 odd–odd OK
	test.ok(grid.is_valid_zsb_area_size(), "Valid odd-odd area should pass")

	grid.configure(make_empty_map(10, 11))
	test.ok(not grid.is_valid_zsb_area_size(), "Even-sized area should fail")

	grid.configure(make_empty_map(3, 5))
	test.ok(not grid.is_valid_zsb_area_size(), "Too small should fail")

	grid = configure_simple_zsb_grid()
	test.ok(grid.is_valid_zsb_area_size(), "Valid zsb map should pass")

	zsb_size = (3, 3)
	zsb_map1 = make_empty_zsb_map(*zsb_size)
	zsb_map2 = make_empty_zsb_map_with_wall_border(*zsb_size)
	for map, descr in [zsb_map1, "without borders"], [zsb_map2, "with borders"]:
		grid.configure(map)
		show_map_if_verbose(grid, f"Empty zsb map {zsb_size} {descr}")
		test.ok(grid.is_valid_zsb_area_size(), "Valid empty zsb map should pass")
		test.eq(grid.get_zsb_size(), zsb_size)
		test.eq(grid.get_zsb_size_str(), '3x3')

	test.eq(zsb_map1.shape, (7, 7))
	test.eq(zsb_map2.shape, (9, 9))
	test.ok((zsb_map1 == zsb_map2[1:8, 1:8]).all(), "Two empty zsb maps (without and with border) should match")

def test_zsb_wall_and_anchor_pattern():
	grid = Grid()
	# build map 7x7 with 9 zsb walls
	grid.configure(make_empty_zsb_map_with_wall_border(3, 3))
	wall_cells = grid.get_zsb_wall_cells()
	for cx, cy in wall_cells:
		test.ok(cx % 2 == 0 and cy % 2 == 0, "All walls on area odd-odd cells")

	anchor_cells = grid.get_all_zsb_anchor_cells()
	for cell in anchor_cells:
		test.ok(grid.is_zsb_anchor_cell(cell), "Anchor cell check should be consistent")

	# check move type symmetry
	for cell in anchor_cells:
		test.is_in(grid.get_zsb_anchor_move_type(cell), (MOVE_H, MOVE_V))

def test_zsb_graph_connected_and_correspondence():
	grid = Grid()
	grid.configure(make_empty_zsb_map_with_wall_border(3, 3))
	barrel_cells = grid.get_all_zsb_anchor_cells()[1 - 3 * 3:]
	test.ok(not grid.is_zsb_graph_connected(barrel_cells), "Last 8 anchor graph should not be connected")

	# break connectivity artificially
	bad_barrel_cells = barrel_cells[:-1]
	test.ok(not grid.is_zsb_graph_connected(bad_barrel_cells), "Missing anchors break connectivity")

	# correspondence
	test.ok(grid.is_zsb_correspondence(barrel_cells, barrel_cells), "Same anchors should correspond to each other")
	reversed_cells = reversed(barrel_cells)
	test.ok(not grid.is_zsb_correspondence(barrel_cells, reversed_cells), "Shuffled anchors should correspond to each other")

	grid = configure_simple_zsb_grid()
	test.ok(grid.is_zsb_graph_connected(grid.barrel_cells), "Barrels on zsb map should be connected")
	test.ok(grid.is_zsb_graph_connected(grid.plate_cells), "Plates on zsb map should be connected")
	test.ok(grid.is_zsb_correspondence(grid.barrel_cells, grid.plate_cells), "Barrels and plates on zsb map should correspond")

def test_zsb_barrel_moves_generation():
	grid = Grid()
	grid.configure(make_empty_zsb_map_with_wall_border(4, 4))
	barrel_cells = grid.get_all_zsb_anchor_cells()[:15]
	moves = grid.get_all_valid_zsb_barrel_moves(barrel_cells)
	test.ok(len(moves) == 0, "There should not be at legal ZSB moves")
	moves = grid.get_all_valid_zsb_barrel_moves(barrel_cells[0:1])
	test.ok(len(moves) != 0, "There should be at least one legal ZSB moves")

	barrel_cells = ((4, 5), (5, 4))
	grid.set_barrels(barrel_cells)  # needed just for show_map
	show_map_if_verbose(grid, "Empty 4x4 ZSB map with border and 2 barrels")
	moves = grid.get_all_valid_zsb_barrel_moves(barrel_cells)
	test.eq(len(moves), 4)

	# ensure all moves are spaced by 2 cells
	for barrel_cell, target_cell in moves:
		test.eq(cell_distance(barrel_cell, target_cell), 2)

	grid = Grid()
	grid.configure(make_empty_zsb_map(6, 4))
	barrel_cells = grid.get_all_zsb_anchor_cells()[6:11]
	grid.set_barrels(barrel_cells)  # needed just for show_map
	show_map_if_verbose(grid, "Empty 6x4 ZSB map without border and 5 barrels")
	moves = grid.get_all_valid_zsb_barrel_moves(barrel_cells)
	test.eq(len(moves), 1)
	barrel_cells = barrel_cells[:-1]  # remove last barrel
	moves = grid.get_all_valid_zsb_barrel_moves(barrel_cells)
	test.eq(len(moves), 2)

def test_zsb_check_zsb_detection():
	grid = Grid()
	grid.configure(make_empty_zsb_map_with_wall_border(5, 3))
	anchor_cells = grid.get_all_zsb_anchor_cells()

	for plate_cells, name in ([anchor_cells[0:1], 'Single'], [anchor_cells[0:14], 'Unconnected'], [anchor_cells, 'Full']):
		grid.plate_bits  = grid.to_bits(plate_cells)
		grid.barrel_bits = grid.to_bits(plate_cells)
		grid.check_zsb()
		test.ok(not grid.is_zsb, f"{name} anchor ZSB map should not be recognized")

	grid.plate_bits  = bitarray('00000000000010010010001000100111100101000001000110000000000000')
	grid.barrel_bits = bitarray('00000000000011110000101010000000000100000101001111000000000000')
	show_map_if_verbose(grid, "Sample 5x3 ZSB map")
	grid.check_zsb()
	test.ok(grid.is_zsb, f"Sample 5x3 ZSB map should be recognized")

	grid = configure_simple_zsb_grid(show_map=True)
	grid.check_zsb()
	test.ok(grid.is_zsb, f"Simple ZSB map should be recognized")

	grid.barrel_bits[0] = True  # corrupt 1-st floor with barrel
	grid.check_zsb()
	test.ok(not grid.is_zsb, "Extra barrel should fail ZSB check")

	grid = configure_simple_zsb_grid()
	grid.configure(grid.map[1:8, 1:8])
	show_map_if_verbose(grid, "Simple ZSB map without border")
	grid.check_zsb()
	test.ok(grid.is_zsb, f"Simple ZSB map without border should be recognized")

	grid.map[0, 0] = CELL_WALL  # corrupt 1-st floor with a wall
	grid.configure(grid.map)
	show_map_if_verbose(grid, "Corrupted simple ZSB map without border")
	grid.check_zsb()
	test.ok(not grid.is_zsb, "Corrupted wall should fail ZSB check")

args = sys.argv[1:]
verbose = args.count('-v') >= 2
test = TestSuite("Grid", '-a' in args, '-v' in args, '-p' in args)
try:
	test_get_accessible_cells()
	test_get_accessible_distance()
	test_get_accessible_distances()
	test_find_path()
	test_push_pull_shift()
	test_all_valid_shifts_consistency()
	test_store_and_restore_barrels()
	test_large_open_area_performance()
	test_deadlock_detection()
	test_find_path_with_barrels()
	test_reverse_mode_consistency()
	test_bit_integrity()
	test_find_path_edge_cases()
	test_conversion_helpers()
	test_show_map_no_crash()
	test_set_barrels_wall_raises()
	test_last_accessible_bits_and_obstacles()
	test_try_push_pull_without_barrel()
	test_zsb_area_size_validation()
	test_zsb_wall_and_anchor_pattern()
	test_zsb_graph_connected_and_correspondence()
	test_zsb_barrel_moves_generation()
	test_zsb_check_zsb_detection()
	test.finalize()
except KeyboardInterrupt:
	print()
	test.ok(False, "Tests terminated by user")
	test.finalize()
