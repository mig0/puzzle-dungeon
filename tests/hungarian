#!/usr/bin/python

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/..')

import random
from itertools import permutations
from hungarian import Hungarian, INF
from colorize import colorize_auto
from testsuite import TestSuite

verbose = sys.argv[1:].count('-v') >= 2

# brute-force solver for verification (n is small)
def brute_force_assignment(costs):
	n = len(costs)
	best_cost = None
	best_perm = None

	for perm in permutations(range(len(costs[0])), n):
		# perm is tuple of distinct column indices of length n
		cost = 0
		for i, j in enumerate(perm):
			cost += costs[i][j]

		if best_cost is None or cost < best_cost:
			best_cost = cost
			best_perm = perm

	return best_cost, list(best_perm)

def is_valid_permutation(assignment, n_rows, n_cols):
	# assignment is list of length n_rows with distinct columns 0..n_cols-1
	return len(assignment) == n_rows and len(set(assignment)) == n_rows and all(0 <= x < n_cols for x in assignment)

def verify_with_bruteforce(h):
	# run h.assign(), compare result with brute force, return result
	total_cost, a = h.assign(), h.a
	if verbose:
		print(colorize_auto("costs: %s" % h.costs))
		print(colorize_auto('total_cost: %s, assigment: %s' % (total_cost, a)))
	exp_total_cost, exp_a = brute_force_assignment(h.costs)
	test.eq(total_cost, exp_total_cost)
	# assignment must be a valid permutation
	test.ok(is_valid_permutation(a, h.n, h.m), "Assignment is invalid")
	# more than one perfect matching may exist, but we rely on random.seed here
	test.eq(a, exp_a)
	return total_cost

# ------------------------------
# Deterministic tests (small n)
# ------------------------------

def test_basic_n1():
	h = Hungarian(1)
	h.costs[0][0] = 7

	total_cost = verify_with_bruteforce(h)
	test.eq(total_cost, 7)
	test.eq(h.a, [0])

def test_basic_n2():
	h = Hungarian(2)
	h.costs[0][0] = 1
	h.costs[0][1] = 5
	h.costs[1][0] = 4
	h.costs[1][1] = 2

	verify_with_bruteforce(h)

def test_basic_n3():
	h = Hungarian(3)
	h.costs = [
		[4, 1, 3],
		[2, 0, 5],
		[3, 2, 2],
	]

	verify_with_bruteforce(h)

# ------------------------------
# Random and rectangular tests
# ------------------------------

def test_random_small():
	random.seed(125)

	for _ in range(20):
		n = 4
		h = Hungarian(n)
		h.costs = [[random.randint(0, 20) for _ in range(n)] for _ in range(n)]

		verify_with_bruteforce(h)

def test_rectangular_more_cols():
	# 3 rows, 5 cols
	n = 3
	m = 5
	h = Hungarian(n, m)

	random.seed(42)

	# fill costs for real rows and cols, extra padded rows remain zero
	for i in range(n):
		for j in range(m):
			h.costs[i][j] = random.randint(1, 9)

	verify_with_bruteforce(h)
	test.eq(len(h.a), n)

def test_rectangular_more_rows():
	# 5 rows, 3 cols, illegal
	test.catch(lambda: Hungarian(5, 3), "Expected to raise when n_rows > n_cols")

def test_rectangular_basic():
	h = Hungarian(2, 3)
	h.costs = [
		[1, 10, 3],
		[2, 10, 7],
	]

	total_cost = verify_with_bruteforce(h)
	test.eq(total_cost, 5)
	test.eq(h.a, [2, 0])

def test_zero_cost_matrix():
	h = Hungarian(4)
	for i in range(4):
		for j in range(4):
			h.costs[i][j] = 0

	total_cost = verify_with_bruteforce(h)
	test.eq(total_cost, 0)
	test.eq(h.a, [0, 1, 2, 3])

def test_large_equal_values():
	h = Hungarian(5)
	for i in range(5):
		for j in range(5):
			h.costs[i][j] = 7

	total_cost = verify_with_bruteforce(h)
	test.eq(total_cost, 7 * 5)

# ------------------------------
# Invalid / edge cases
# ------------------------------

def test_invalid_inf_row():
	# a whole row INF should make algorithm stuck â€” expect assertion
	h = Hungarian(3)
	for j in range(3):
		h.costs[0][j] = INF
	h.costs[1][0] = 1
	h.costs[1][1] = 2
	h.costs[1][2] = 3
	h.costs[2][0] = 4
	h.costs[2][1] = 5
	h.costs[2][2] = 6

	test.catch(lambda: h.assign())

def test_partial_inf_row():
	# a partial INF rows while still assigment exist should pass
	h = Hungarian(3, 4)
	h.costs = [
		[INF, INF,   3,   4],
		[  5, INF, INF, INF],
		[  1, INF,   3, INF],
	]

	total_cost = verify_with_bruteforce(h)
	test.eq(total_cost, 12)
	test.eq(h.a, [3, 0, 2])

def test_negative_values_are_allowed():
	# negative values are not inherently invalid; ensure algorithm matches brute force
	h = Hungarian(3)
	h.costs = [
		[-5, 1, 4],
		[2, -3, 0],
		[7, 2, -1],
	]

	verify_with_bruteforce(h)

# --------------------------------------------------------------------

test = TestSuite("Hungarian")
test_basic_n1()
test_basic_n2()
test_basic_n3()
test_random_small()
test_rectangular_more_cols()
test_rectangular_more_rows()
test_rectangular_basic()
test_zero_cost_matrix()
test_large_equal_values()
test_invalid_inf_row()
test_partial_inf_row()
test_negative_values_are_allowed()
test.finalize()
